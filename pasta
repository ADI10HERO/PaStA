#!/usr/bin/env python3

"""
PaStA - Patch Stack Analysis
A tool for tracking the evolution of patch stacks

Copyright (c) OTH Regensburg, 2016-2020

Author:
  Ralf Ramsauer <ralf.ramsauer@oth-regensburg.de>

This work is licensed under the terms of the GNU GPL, version 2.  See
the COPYING file in the top-level directory.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.
"""

import gc
import logging
import os
import sys

from cmd import Cmd
from copy import deepcopy

from pypasta import Config

from bin.pasta_analyse import analyse
from bin.pasta_check_connectivity import check_connectivity
from bin.pasta_check_mbox import check_mbox
from bin.pasta_compare import compare
from bin.pasta_compare_clusters import compare_clusters
from bin.pasta_maintainers_stats import maintainers_stats
from bin.pasta_optimise_cluster import optimise_cluster
from bin.pasta_prepare_evaluation import prepare_evaluation
from bin.pasta_rate import rate
from bin.pasta_ripup import ripup
from bin.pasta_show_cluster import show_cluster
from bin.pasta_statistics import statistics
from bin.pasta_sync import sync
from bin.pasta_compare_stacks import compare_stacks
from bin.pasta_patch_descriptions import patch_descriptions
from bin.pasta_upstream_duration import upstream_duration
from bin.pasta_upstream_history import upstream_history
from bin.pasta_web import web
from bin.pasta_form_patchwork_relations import form_patchwork_relations


__author__ = 'Ralf Ramsauer'
__copyright__ = 'Copyright (c) OTH Regensburg, 2016-2020'
__credits__ = ['Ralf Ramsauer']
__license__ = 'GPLv2'
__version__ = '0.3'
__maintainer__ = 'Ralf Ramsauer'
__email__ = 'ralf.ramsauer@oth-regensburg.de'
__status__ = 'Development'

log = logging.getLogger('PaStA')
config = None


def usage(shell):
    print(
        'PaStA - The Patch Stack Analysis (PaStA v%s)\n'
        '\n'
        'usage: pasta [-d] {[-s|--script filename] | sub [args...] | [-h|--help]}\n'
        ' -d: enable debug messages\n\n'
        'By default, PaStA will choose the configuration stored in \'./config\'.\n'
        'Available subcommands are listed below. Type \'pasta sub -h\' to get\n'
        'help for a specific subcommand. Type \'pasta shell\' to start an\n'
        'interactive shell.'
        % __version__)

    shell.onecmd('?')


def select_config(project_name=None, verbose=True):
    global config

    if not project_name:
        with open('./config', 'r') as f:
            project_name = f.read().strip()

    # We have nothing to do if the configuration is already loaded
    if config and config.project_name == project_name:
        if verbose:
            log.info('Already active: %s' % project_name)
        return True

    # Try to load the new configuration
    try:
        tmp = Config(project_name)
    except Exception as e:
        log.error('Unable to load %s: %s' % (project_name, str(e)))
        return False

    # We need to reload the configuration object. Delete the current one, if existent
    if config:
        del config
        gc.collect()
    config = tmp
    return True


def requires_config(func):
    def wrapper(*args, **kwargs):
        if not config:
            select_config()
        func(*args, **kwargs)
    return wrapper


class PastaShell(Cmd):
    prompt = 'PaStA>>> '
    intro = 'PaStA - The Patch Stack Analysis (PaStA %s)\n' \
            'Type ? for a list of all commands' % (__version__)

    def __init__(self):
        super(PastaShell, self).__init__()

    def default(self, line: str) -> bool:
        if line in ['x', 'q', 'quit']:
            return self.do_exit(line)

        print('*** Unknown syntax: %s' % line)
        return False

    @requires_config
    def do_analyse(self, line):
        analyse(config, line.split())

    @requires_config
    def do_check_connectivity(self, line):
        check_connectivity(config, line.split())

    @requires_config
    def do_check_mbox(self, line):
        check_mbox(config, line.split())

    @requires_config
    def do_compare(self, line):
        compare(config, line.split())

    def do_compare_clusters(self, line):
        compare_clusters(line.split())

    @requires_config
    def do_compare_stacks(self, line):
        compare_stacks(config, line.split())

    def do_config(self, line):
        line = line.split()
        if len(line) == 0:
            if config:
                log.info('Active configuration: %s' % config.project_name)
            else:
                log.info('No configuration loaded')
            return
        sub = line.pop(0)
        if len(line) > 1 or sub not in ['load', 'save']:
            log.error('Unknown command: config %s %s' % (sub, ' '.join(line)))
            return

        project_name = None
        if len(line):
            project_name = line[0]

        if sub == 'load':
            select_config(project_name, verbose=True)
        elif sub == 'save':
            if not project_name:
                if config:
                    project_name = config.project_name
                else:
                    log.error('No configuration loaded')
                    return

            if select_config(project_name, verbose=False):
                config.set_config()

    def do_exit(self, line):
        log.info('Bye')
        return True

    def do_form_patchwork_relations(self, line):
        form_patchwork_relations(config, line.split())

    @requires_config
    def do_maintainers_stats(self, line):
        maintainers_stats(config, line.split())

    def do_optimise_cluster(self, line):
        optimise_cluster(line.split())

    @requires_config
    def do_patch_descriptions(self, line):
        if len(line.split()):
            log.error('Unknown arguments: %s' % line)
        patch_descriptions(config)

    @requires_config
    def do_prepare_evaluation(self, line):
        prepare_evaluation(config, line.split())

    @requires_config
    def do_rate(self, line):
        rate(config, line.split())

    @requires_config
    def do_ripup(self, line):
        ripup(config, line.split())

    @requires_config
    def do_show_cluster(self, line):
        show_cluster(config, line.split())

    @requires_config
    def do_statistics(self, line):
        statistics(config, line.split())

    @requires_config
    def do_sync(self, line):
        sync(config, line.split())

    @requires_config
    def do_upstream_duration(self, line):
        upstream_duration(config, line.split())

    @requires_config
    def do_upstream_history(self, line):
        upstream_history(config, line.split())

    @requires_config
    def do_web(self, line):
        web(config, line.split())

    @requires_config
    def help_analyse(self):
        analyse(config, ['-h'])

    @requires_config
    def help_check_connectivity(self):
        check_connectivity(config, ['-h'])

    @requires_config
    def help_check_mbox(self):
        check_mbox(config, ['-h'])

    @requires_config
    def help_compare(self):
        compare(config, ['-h'])

    def help_compare_clusters(self):
        compare_clusters(['-h'])

    @requires_config
    def help_compare_stacks(self):
        compare_stacks(config, ['-h'])

    def help_config(self):
        print(
            'config - print current configuration\n'
            'config load [<project_name>] - load project_name configuration. Load the default configuration of no project_name given\n'
            'config save [<project_name>] - load project_name and set default configuration. Set the active configuration if no project provided.'
        )

    def help_exit(self):
        print('Exit PaStA. Usual suspect shorthands: x q quit Ctrl-D')

    def help_form_patchwork_relations(self):
        form_patchwork_relations(config, ['-h'])

    @requires_config
    def help_maintainers_stats(self):
        maintainers_stats(config, ['-h'])

    def help_optimise_cluster(self):
        optimise_cluster(['-h'])

    @requires_config
    def help_prepare_evaluation(self):
        prepare_evaluation(config, ['-h'])

    @requires_config
    def help_rate(self):
        rate(config, ['-h'])

    @requires_config
    def help_ripup(self):
        ripup(config, ['-h'])

    @requires_config
    def help_show_cluster(self):
        show_cluster(config, ['-h'])

    @requires_config
    def help_statistics(self):
        statistics(config, ['-h'])

    @requires_config
    def help_sync(self):
        sync(config, ['-h'])

    @requires_config
    def help_upstream_duration(self):
        upstream_duration(config, ['-h'])

    @requires_config
    def help_upstream_history(self):
        upstream_history(config, ['-h'])

    do_EOF = do_exit


def main(argv):
    global config

    # drop the name of the command
    argv.pop(0)

    script = None
    shell = PastaShell()
    level = logging.INFO
    while len(argv) and argv[0].startswith('-'):
        argument = argv.pop(0)
        if argument == '-d':
            level = logging.DEBUG
        elif argument in {'-h', '--help'}:
            usage(shell)
            return 0
        elif argument in {'-s', '--script'}:
            if len(argv) != 1:
                usage(shell)
                return -1
            f_script = argv.pop()
            if not os.path.isfile(f_script):
                log.error('%s: no such file' % f_script)
            with open(f_script, 'r') as f:
                content = f.read().splitlines()
            script = list()
            for lineno, line in enumerate(content):
                if len(line) == 0 or line[0] == '#':
                    continue
                script.append((lineno + 1, line))
        else:
            usage(shell)
            return -1

    fmt = '%(asctime)-15s %(name)-15s %(levelname)-8s %(message)s'
    logging.basicConfig(level=level, stream=sys.stdout, format=fmt)
    filehandler = logging.FileHandler(filename='./log', mode='a')
    filehandler.setFormatter(logging.Formatter(fmt))
    logging.getLogger().addHandler(filehandler)
    log.info('Cmdline: ' + ' '.join(sys.argv))

    if script:
        for lineno, line in script:
            ret = shell.onecmd(line)
            if ret == False:
                log.error('Error executing line %u: %s' % (lineno, line))
                return -1
        return 0

    if not argv:
        usage(shell)
        return -1

    sub = argv.pop(0)
    if sub == 'shell':
        shell.cmdloop()
        return 0

    cmd = '%s %s' % (sub, ' '.join(argv))
    ret = shell.onecmd(cmd)

    return ret is not None


if __name__ == '__main__':
    ret = main(deepcopy(sys.argv))
    log.info('Shutting down')
    sys.exit(ret if ret else 0)
